\chapter{Comprensión de Programas}

La \textit{Comprensión de Programas} es una disciplina de la Ingeniería de Software
cuyo objetivo es proveer \textit{Modelos, Métodos, Técnicas} y \textit{Herramientas}
para facilitar el estudio y entendimiento de los sistemas de software \cite{BeronHenriquesPereiraXX}.

"Permite que el programador pueda localizar rápidamente los objetos del programa que se
utilizaron para una funcionalidad específica del sistema de estudio.
Si el sistema que se está analizando es pequeño (5 Kloc o menos) entonces las bondades 
de este tipo de relación no se pueden apreciar claramente.
Pero si el sistema es de gran envergadura la relación antes mencionada disminuye el
esfuerzo del programador."\cite{BeronHenriquesPereiraXX}

"Por otra parte, los costos implicados en la modificación, mantenimiento o evolución
del sistema disminuyen debido a que se reduce el tiempo requerido por el programador
para la realización de la tarea."\cite{BeronHenriquesPereiraXX}

"Software development is a complex undertaking, involving a number of related tasks: specification,
design, implementation, testing, debugging, maintenance, modification, re-engineering. Each of those
tasks involves a number of cognitive demands, such as search, comprehension, analysis, problem
solving, representation. It’s no wonder that software development is so often described as complex.
The complexity derives from the nature of the problems addressed, the diversity of the tasks involved,
the nature of the artefacts produced, the changing social and organisational environment in which it is
conducted, and the impact of time on environment, needs, teams, and artefacts."\cite{PetreDeQuency06}

"Los modelos cognitivos [12] son importantes porque son la base para la construcción de herramientas
de comprensión de programas [16].
En este ámbito, diversos autores han presentado diferentes modelos cognitivos para describir
la forma que tienen de entender los sistemas los programadores.
Los artículos [12][14][17] nos permiten distinguir las siguientes formas principales de comprensión:
desde conceptos específicos hacia conceptos generales (Bottom Up), desde conceptos generales
hacia conceptos específicos (Top Down), Comprensión Basada en una Base de Conocimiento (Knowledge
based Understanding Model), Comprensión Oportunista y Sistemática (Systematic and As Needed Program
Understanding), Modelos Integrados (Strategies and Integrated Techniques)."
\cite{BeronHenriquesPereiraUzalXX}

"Software ages as this social and organisational context evolves: teams change,
knowledge decays, documentation falls out of date, intentions and rationale are forgotten over time
(Ball and Eick, 1996)."

\section{Modelos de Comprensión de Programas}
Generalmente, se establece que la \textit{comprensión}, dentro de este ámbito de estudio es un
proceso en el que el individuo construye su propia representación mental de un programa.
Si bien existen varias escuelas de pensamiento, independientemente de las diferencias, la
mayoría de los modelos de comprensión de programas contiene un conjunto común de elementos,
tal como se puede ver en la Figura X TOOOODOOOOOO.

\subsection{Representación Externa}
Se considera que la representación externa son todos aquellos materiales asociados al programa
en estudio que el programador puede utilizar para su proceso de comprensión, pero que no son 
parte del conocimiento interno del individuo.
Estos elementos pueden ser presentados de diversa forma, incluyendo directamente el código fuente,
hasta manuales, documentación, diagramas UML, entre otros.

\subsection{Estructura Cognitiva}
El conocimiento interno de un programador, el cual puede dividirse entre base de conocimiento
y representación mental, es lo que se define como estructura cognitiva.

La base de conocimiento viene dada por el conocimiento general que el programador posee,
independiente de la aplicación específica que se está tratando de comprender.
Esto incluye conocimiento general de lenguajes y principios de programación, algoritmos, 
aplicaciones similares y demás.

El modelo mental es una representación interna al programador del software bajo consideración.
Determina el nivel de conocimiento del individuo sobre el sistema en cuestión, y es construido
a medida que se comprende, utilizando la base de conocimiento mencionada anteriormente.
Diferentes elementos, tanto estáticos como dinámicos, forman parte del modelo y permiten
su evolución.\cite{MayrhauserVans95}

\subsection{Proceso de Asimilación}
La estrategia implementada por los desarrolladores para extraer información de un programa, 
construir una representación mental del mismo, y así lograr su comprensión, es lo que se
conoce como proceso de asimilación.

\begin{description}
    \item[Top-down] Los modelos de comprensión top-down son aquellos que implican la
    aplicación de conocimiento sobre el dominio del programa y la correlación de este
    conocimiento con el código fuente del mismo.
    En el modelo de Brooks, una sucesión de hipótesis forma el proceso de asimilación.
    En el esquema de Soloway y Erlich, los programadores utilizan planes y reglas de programación
    para descomponer objetivos y planes en otros planes de menor abstracción.
     
    \item[Bottom-up] Caen dentro de esta clasificación aquellos modelos en
    los que su proceso de asimilación comienza con las sentencias de código fuente, y
    las mismas se van agrupando y así obteniendo mayores niveles de abstracción.
    El proceso se repite una y otra vez, hasta lograr una representación mental completa
    del programa en cuestión.
    En el proceso de asimilación propuesto por Pennington, se presentan dos modelos diferentes.
    El modelo del programa, que se obtiene de agrupar microestructuras en macroestructuras, y
    se corresponde con una abstracción del flujo de control del programa.
    El modelo de situación, incluye el flujo de datos dentro del programa, y representa la
    función y objetivos del mismo.
    En el modelo de Shneiderman y Mayer, la base de conocimiento se compone tanto de
    conocimiento sintáctico como semántico.
    A mayor experiencia del desarrollar, mayor será este último.

    \item[Oportunista] Algunos autores consideran que, dependiendo
    de la necesidad de comprensión para la tarea en cuestión, no existe un enfoque
    sistemático de resolución.
    Algunos autores consideran que no existe un enfoque sistemático de asimilación,
    y que dependiendo de la necesidad de comprensión, un programador puede aprovechar
    las estrategias tanto bottom-up como top-down.
    Letovsky plantea que un programador puede procesar la información de forma bottom-up
    o top-down a medida que van apareciendo pistas que ayuden a su comprensión.
    
    \item[Modelos Integrados] Los modelos integrados suponen una combinación de los
    anteriores, en donde el proceso de asimilación implica ir cambiando de
    modelos a medida que se requiera, para poder construirlos simultáneamente.
    Se plantean tres representaciones mentales: el modelo del dominio, el modelo del
    programa y el modelo de situación.
    Es muy importante la base de conocimiento del programador, ya que le va a permitir
    la construcción de las representaciones.

\end{description}

\section{Visualización de Software}

La visualización de software refiere al uso de diversos elementos (texto, 
gráficos 2D y 3D, diagramas, imágenes, vídeos, entre otros) para representar algún
aspecto de un programa y facilitar su comprensión.\cite{PetreDeQuency06}\cite{[GH01]Che06]}
Estos aspectos u objetos de interés pueden ser abstracciones de componentes, de
un sistema completo e incluso del comportamiento en tiempo en ejecución de los
mismos. \cite{TeysereCampo09}

Las visualizaciones pueden ayudan al programador con tres procesos cognitivos
\cite{ButlerAlmond93}:
durante un proceso de descubrimiento o exploratorio, en donde el usuario no
sabe específicamente qué está buscando;
durante un proceso de toma de decisión o analítico, en el cuál el usuario sabe lo que
está buscando y sólo necesito encontrarlo;
durante un proceso descriptivo, en el cuál es conocido el patrón que aparece en los
datos pero necesita una visualización acorde para expresarlo.

Estos procesos cognitivos que se pueden ver beneficiados por las visualizaciones, suelen
emplearse en diferentes tareas que puede llevar a cabo un programador.
Dentro de esta lista de tareas \cite{MalleticMarcusCollard02} encontramos: desarollo,
debugging, pruebas, mantenimiento y detección de errores, re-ingeniería, ingeniería reversa,
administración del proceso de software, y marketing.
En las primeras etapas del desarrollo de un nuevo sistema o aplicación, las visualizaciones
permiten la colaboración entre desarrolladores y ayudar en la definición y validación de los
requerimientos.
A medida que se avanza en la construcción del software, las herramientas permiten validar
los avances y encontrar defectos.
En el caso de mantenimiento, ayudan en la comprensión del programa, entender su diseño y
así plantear su evolución \cite{PetreDeQuency06}.

Algoritmos, programas y sistemas son los diferentes alcances que se consideran
dento de la disciplina de Visualización de Software.\cite{[PBS93][Mye90]}
La Visualización de Sistemas se emplea para representar el sistema en su conjunto,
a través de los diferentes módulos que lo componen.
En la visualización de Programas, se busca mostrar el comportamiento de los mismos
y la relación entre sus componentes \cite{BA01}.
Por último, la Visualización de Algoritmos se utiliza principalmente en el campo de la enseñanza,
para demostrar el funcionamiento de algoritmos y estructuras de datos.
Así mismo, tal como denota la expresión 
"Alg. V isualization < P rog. V isualization < Sys. V isualization"\cite{PIROBV-YDS-2007}
las técnicas implementadas en un determinado alcance, pueden ser implementadas
también en un conjunto de mayor nivel de abstracción.

La taxonomía de Price, Baecker y Small \cite{PriceBaeckerSmallXX}, establece que
existen seis categorías de atributos para los sistemas de visualización.
Dentro de las mismas podemos encontrar:
\begin{enumerate}
    \item \textbf{Alcance:} refiere al espectro de programas que pueden ser analizados.
    \item \textbf{Contenido:} corresponde al conjunto de propiedades del sistema que se pueden
    extraer y visualizar.
    \item \textbf{Forma:} relacionada a la salida de los resultados de la visualización.
    \item \textbf{Método:} determina cómo está especificada la visualización.
    \item \textbf{Interacción:} referida la manera en la que el usuario pueda controlar e
    interactuar con la visualización.
    \item \textbf{Efectividad:} grado de adecuación con el cual se comunica la información
    al usuario.
\end{enumerate}
Del listado anterior, la categoría y por lo tanto la característica más importante corresponde
a la \textit{efectividad}.

Dependiendo de la fuente de datos, las visualizaciones pueden estar basadas en
estructuras estáticas (cuando se obtienen de vistas del código fuente), o de
información extraída en tiempo de ejecución (vistas dinámicas, así sean de flujo de datos
o control de flujo). \cite{PetreDeQuency06}
Las estrategias para la obtención de los datos se discuten a continuación.

\section{Métodos de Extracción de la Información}

El \textbf{análisis estático} del software consiste en obtener información sobre el 
sistema de interés, pero sin ejecutarlo.
Los \textit{analizadores sintácticos} operan a nivel de código fuente, empleando
técnicas tanto de \textit{pattern matching} como de construcción de árboles de sintáxis
abstracta (\textit{Abstract-Syntax Tree}).
Los \textit{analizadores semánticos} trajaban de una manera diferente, ya que consideran
la secuencia en la que pueden darse los estados de un programa, en una ejecución.
La premisa principal consiste en que analizar los posibles estados de un programa en un
punto determinado, son suficientes para probar propiedades estáticas del mismo.
\cite{Cousot77}

El \textbf{análisis dinámico} corresponde a la extracción de propiedades de un sistema
en ejecución.
Estas propiedades son obtenidas al examinar una o más ejecuciones de un programa, a
través de diferentes técnicas.
Generalmente, se obtiene a través de la instrumentación del código fuente, y así
analizar los aspectos que son de interés; y es muy dependiente del input que reciba
el programa.
\cite{Ball90}

\section{Estrategias de Interrelación de Dominios}

SVS (Simultaneous Visualization Strategy).

BORS (Behavioral Operational Relation Strategy).

SVSi (Simultaneous Visualization Strategy Improved).
